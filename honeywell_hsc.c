/*
 * Honeywell TruStability HSC Series pressure/temperature sensor
 *
 * Copyright (c) 2023 Petre Rodan <2b4eda@subdimension.ro>
 *
 * Datasheet: https://prod-edam.honeywell.com/content/dam/honeywell-edam/sps/siot/en-us/products/sensors/pressure-sensors/board-mount-pressure-sensors/trustability-hsc-series/documents/sps-siot-trustability-hsc-series-high-accuracy-board-mount-pressure-sensors-50099148-a-en-ciid-151133.pdf?download=false
 */

#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/init.h>
#include <linux/math64.h>
#include <linux/units.h>
#include <linux/mod_devicetable.h>
#include <linux/printk.h>

#include <linux/iio/iio.h>
#include <linux/iio/sysfs.h>

#include "honeywell_hsc.h"

struct hsc_config {                             // pressure range for current chip
	int min;
	int max;
};

// all min max limits have been converted to pascals
// code generated by scripts/parse_variants_table.sh
static const struct hsc_config hsc_config[] = {
	[HSC001BA] = { .min =       0, .max =  100000 },
	[HSC1_6BA] = { .min =       0, .max =  160000 },
	[HSC2_5BA] = { .min =       0, .max =  250000 },
	[HSC004BA] = { .min =       0, .max =  400000 },
	[HSC006BA] = { .min =       0, .max =  600000 },
	[HSC010BA] = { .min =       0, .max = 1000000 },
	[HSC1_6MD] = { .min =    -160, .max =     160 },
	[HSC2_5MD] = { .min =    -250, .max =     250 },
	[HSC004MD] = { .min =    -400, .max =     400 },
	[HSC006MD] = { .min =    -600, .max =     600 },
	[HSC010MD] = { .min =   -1000, .max =    1000 },
	[HSC016MD] = { .min =   -1600, .max =    1600 },
	[HSC025MD] = { .min =   -2500, .max =    2500 },
	[HSC040MD] = { .min =   -4000, .max =    4000 },
	[HSC060MD] = { .min =   -6000, .max =    6000 },
	[HSC100MD] = { .min =  -10000, .max =   10000 },
	[HSC160MD] = { .min =  -16000, .max =   16000 },
	[HSC250MD] = { .min =  -25000, .max =   25000 },
	[HSC400MD] = { .min =  -40000, .max =   40000 },
	[HSC600MD] = { .min =  -60000, .max =   60000 },
	[HSC001BD] = { .min = -100000, .max =  100000 },
	[HSC1_6BD] = { .min = -160000, .max =  160000 },
	[HSC2_5BD] = { .min = -250000, .max =  250000 },
	[HSC004BD] = { .min = -400000, .max =  400000 },
	[HSC2_5MG] = { .min =       0, .max =     250 },
	[HSC004MG] = { .min =       0, .max =     400 },
	[HSC006MG] = { .min =       0, .max =     600 },
	[HSC010MG] = { .min =       0, .max =    1000 },
	[HSC016MG] = { .min =       0, .max =    1600 },
	[HSC025MG] = { .min =       0, .max =    2500 },
	[HSC040MG] = { .min =       0, .max =    4000 },
	[HSC060MG] = { .min =       0, .max =    6000 },
	[HSC100MG] = { .min =       0, .max =   10000 },
	[HSC160MG] = { .min =       0, .max =   16000 },
	[HSC250MG] = { .min =       0, .max =   25000 },
	[HSC400MG] = { .min =       0, .max =   40000 },
	[HSC600MG] = { .min =       0, .max =   60000 },
	[HSC001BG] = { .min =       0, .max =  100000 },
	[HSC1_6BG] = { .min =       0, .max =  160000 },
	[HSC2_5BG] = { .min =       0, .max =  250000 },
	[HSC004BG] = { .min =       0, .max =  400000 },
	[HSC006BG] = { .min =       0, .max =  600000 },
	[HSC010BG] = { .min =       0, .max = 1000000 },
	[HSC100KA] = { .min =       0, .max =  100000 },
	[HSC160KA] = { .min =       0, .max =  160000 },
	[HSC250KA] = { .min =       0, .max =  250000 },
	[HSC400KA] = { .min =       0, .max =  400000 },
	[HSC600KA] = { .min =       0, .max =  600000 },
	[HSC001GA] = { .min =       0, .max = 1000000 },
	[HSC160LD] = { .min =    -160, .max =     160 },
	[HSC250LD] = { .min =    -250, .max =     250 },
	[HSC400LD] = { .min =    -400, .max =     400 },
	[HSC600LD] = { .min =    -600, .max =     600 },
	[HSC001KD] = { .min =   -1000, .max =    1000 },
	[HSC1_6KD] = { .min =   -1600, .max =    1600 },
	[HSC2_5KD] = { .min =   -2500, .max =    2500 },
	[HSC004KD] = { .min =   -4000, .max =    4000 },
	[HSC006KD] = { .min =   -6000, .max =    6000 },
	[HSC010KD] = { .min =  -10000, .max =   10000 },
	[HSC016KD] = { .min =  -16000, .max =   16000 },
	[HSC025KD] = { .min =  -25000, .max =   25000 },
	[HSC040KD] = { .min =  -40000, .max =   40000 },
	[HSC060KD] = { .min =  -60000, .max =   60000 },
	[HSC100KD] = { .min = -100000, .max =  100000 },
	[HSC160KD] = { .min = -160000, .max =  160000 },
	[HSC250KD] = { .min = -250000, .max =  250000 },
	[HSC400KD] = { .min = -400000, .max =  400000 },
	[HSC250LG] = { .min =       0, .max =     250 },
	[HSC400LG] = { .min =       0, .max =     400 },
	[HSC600LG] = { .min =       0, .max =     600 },
	[HSC001KG] = { .min =       0, .max =    1000 },
	[HSC1_6KG] = { .min =       0, .max =    1600 },
	[HSC2_5KG] = { .min =       0, .max =    2500 },
	[HSC004KG] = { .min =       0, .max =    4000 },
	[HSC006KG] = { .min =       0, .max =    6000 },
	[HSC010KG] = { .min =       0, .max =   10000 },
	[HSC016KG] = { .min =       0, .max =   16000 },
	[HSC025KG] = { .min =       0, .max =   25000 },
	[HSC040KG] = { .min =       0, .max =   40000 },
	[HSC060KG] = { .min =       0, .max =   60000 },
	[HSC100KG] = { .min =       0, .max =  100000 },
	[HSC160KG] = { .min =       0, .max =  160000 },
	[HSC250KG] = { .min =       0, .max =  250000 },
	[HSC400KG] = { .min =       0, .max =  400000 },
	[HSC600KG] = { .min =       0, .max =  600000 },
	[HSC001GG] = { .min =       0, .max = 1000000 },
	[HSC015PA] = { .min =       0, .max =  103425 },
	[HSC030PA] = { .min =       0, .max =  206850 },
	[HSC060PA] = { .min =       0, .max =  413700 },
	[HSC100PA] = { .min =       0, .max =  689500 },
	[HSC150PA] = { .min =       0, .max = 1034250 },
	[HSC0_5ND] = { .min =    -125, .max =     125 },
	[HSC001ND] = { .min =    -249, .max =     249 },
	[HSC002ND] = { .min =    -498, .max =     498 },
	[HSC004ND] = { .min =    -996, .max =     996 },
	[HSC005ND] = { .min =   -1245, .max =    1245 },
	[HSC010ND] = { .min =   -2491, .max =    2491 },
	[HSC020ND] = { .min =   -4982, .max =    4982 },
	[HSC030ND] = { .min =   -7473, .max =    7473 },
	[HSC001PD] = { .min =   -6895, .max =    6895 },
	[HSC005PD] = { .min =  -34475, .max =   34475 },
	[HSC015PD] = { .min = -103425, .max =  103425 },
	[HSC030PD] = { .min = -206850, .max =  206850 },
	[HSC060PD] = { .min = -413700, .max =  413700 },
	[HSC001NG] = { .min =       0, .max =     249 },
	[HSC002NG] = { .min =       0, .max =     498 },
	[HSC004NG] = { .min =       0, .max =     996 },
	[HSC005NG] = { .min =       0, .max =    1245 },
	[HSC010NG] = { .min =       0, .max =    2491 },
	[HSC020NG] = { .min =       0, .max =    4982 },
	[HSC030NG] = { .min =       0, .max =    7473 },
	[HSC001PG] = { .min =       0, .max =    6895 },
	[HSC005PG] = { .min =       0, .max =   34475 },
	[HSC015PG] = { .min =       0, .max =  103425 },
	[HSC030PG] = { .min =       0, .max =  206850 },
	[HSC060PG] = { .min =       0, .max =  413700 },
	[HSC100PG] = { .min =       0, .max =  689500 },
	[HSC150PG] = { .min =       0, .max = 1034250 },
};

/*
 * the first two bits from the first byte contain a status code
 *
 * 00 - normal operation, valid data
 * 01 - device in hidden factory command mode
 * 10 - stale data
 * 11 - diagnostic condition
 *
 * function returns 1 only if both bits are zero
 */
static bool hsc_measurement_is_valid(struct hsc_data *data)
{
	if (data->buffer[0] & 0xc0)
		return 0;

	return 1;
}

static int hsc_get_measurement(struct hsc_data *data)
{
	const struct hsc_chip_data *chip = data->chip;
	int ret;

	/* don't bother sensor more than once a second */
	if (!time_after(jiffies, data->last_update + HZ)) {
		return data->is_valid ? 0 : -EAGAIN;
	}

	data->is_valid = false;
	data->last_update = jiffies;

	ret = data->xfer(data);

	if (ret < 0)
		return ret;

	pr_info("recvd %02x %02x %02x %02x, status %02x\n", data->buffer[0],
		data->buffer[1], data->buffer[2], data->buffer[3], chip->valid(data));

	ret = chip->valid(data);
	if (!ret)
		return -EAGAIN;

	data->is_valid = true;

	return 0;
}

/*
4 bytes are read, the dissection looks like

.  0  .  1  .  2  .  3  .  4  .  5  .  6  .  7  .
byte 0:
|  s1 |  s0 | b13 | b12 | b11 | b10 |  b9 |  b8 |
| status    | bridge data (pressure) MSB        |
byte 1:
|  b7 |  b6 |  b5 |  b4 |  b3 |  b2 |  b1 |  b0 |
| bridge data (pressure) LSB                    |
byte 2:
| t10 |  t9 |  t8 |  t7 |  t6 |  t5 |  t4 |  t3 |
| temperature data MSB                          |
byte 3:
|  t2 |  t1 |  t0 |  X  |  X  |  X  |  X  |  X  |
| temperature LSB | ignore                      |

.  0  .  1  .  2  .  3  .  4  .  5  .  6  .  7  .

*/

static int hsc_read_raw(struct iio_dev *indio_dev,
			struct iio_chan_spec const *channel, int *val,
			int *val2, long mask)
{
	struct hsc_data *data = iio_priv(indio_dev);
	int ret = -EINVAL;

	switch (mask) {

	case IIO_CHAN_INFO_RAW:
		mutex_lock(&data->lock);
		ret = hsc_get_measurement(data);
		mutex_unlock(&data->lock);

		if (ret)
			return ret;

		switch (channel->type) {
		case IIO_PRESSURE:
			*val = ((data->buffer[0] & 0x3f) << 8) + data->buffer[1];
			return IIO_VAL_INT;
		case IIO_TEMP:
			*val = (data->buffer[2] << 3) +
			     ((data->buffer[3] & 0xe0) >> 5);
			ret = 0;
			if (!ret)
				return IIO_VAL_INT;
			break;
		default:
			return -EINVAL;
		}
		break;

/**
 *	IIO ABI expects
 *	value = (conv + offset) * scale
 *
 *	datasheet provides the following formula for determining the temperature
 *	temp[C] = conv * a + b
 *
 *	temp[C] = (conv + (b/a)) * a * (1000)
 *      =>
 *	scale = a * 1000 = .097703957 * 1000 = 97.703957
 *	offset = b/a = -50 / .097703957 = -50000000 / 97704
 *
 *	based on the datasheet
 *	pressure = (conv - HSC_OUTPUT_MIN) * Q + Pmin =
 *	           ((conv - HSC_OUTPUT_MIN) + Pmin/Q) * Q
 *	=>
 *	scale = Q = (Pmax - Pmin) / (HSC_OUTPUT_MAX - HSC_OUTPUT_MIN)
 *	offset = Pmin/Q = Pmin * (HSC_OUTPUT_MAX - HSC_OUTPUT_MIN) / (Pmax - Pmin)
*/

	case IIO_CHAN_INFO_SCALE:
		switch (channel->type) {
		case IIO_TEMP:
			*val = 97;
			*val2 = 703957;
			return IIO_VAL_INT_PLUS_MICRO;
		case IIO_PRESSURE:
			*val = data->p_scale;
			*val2 = data->p_scale_nano;
			return IIO_VAL_INT_PLUS_NANO;
		default:
			return -EINVAL;
		}
		break;

	case IIO_CHAN_INFO_OFFSET:
		switch (channel->type) {
		case IIO_TEMP:
			*val = -50000000;
			*val2 = 97704;
			return IIO_VAL_FRACTIONAL;
		case IIO_PRESSURE:
			*val = data->p_offset;
			*val2 = data->p_offset_nano;
			return IIO_VAL_INT_PLUS_NANO;
		default:
			return -EINVAL;
		}
	}

	return ret;
}

static const struct iio_chan_spec hsc_channels[] = {
	{
	 .type = IIO_PRESSURE,
	 .info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
	 BIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_OFFSET)
	 },
	{
	 .type = IIO_TEMP,
	 .info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
	 BIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_OFFSET)
	 },
};

static const struct iio_info hsc_info = {
	.read_raw = hsc_read_raw,
};

static const struct hsc_chip_data hsc_chip = {
	.valid = hsc_measurement_is_valid,
	.read_size = HSC_REG_MEASUREMENT_RD_SIZE,
	.channels = hsc_channels,
	.num_channels = ARRAY_SIZE(hsc_channels),
};

int hsc_probe(struct iio_dev *indio_dev, struct device *dev,
		 const char *name, int type)
{
	struct hsc_data *hsc;
	int chip_id = type;
	u64 tmp;

	hsc = iio_priv(indio_dev);

	hsc->last_update = jiffies - HZ;
	hsc->chip = &hsc_chip;

	hsc->pmin = hsc_config[chip_id].min;
	hsc->pmax = hsc_config[chip_id].max;

	// multiply with MICRO and then divide by NANO since the output needs
	// to be in KPa as per IIO ABI requirement
	tmp = div_s64(((s64)(hsc->pmax - hsc->pmin)) * MICRO,
				(HSC_OUTPUT_MAX - HSC_OUTPUT_MIN));
	hsc->p_scale = div_s64_rem(tmp, NANO, &hsc->p_scale_nano);
	tmp = div_s64(((s64) hsc->pmin * (s64)(HSC_OUTPUT_MAX - HSC_OUTPUT_MIN)) * MICRO,
				hsc->pmax - hsc->pmin);
	hsc->p_offset = div_s64_rem(tmp, NANO, &hsc->p_offset_nano) - HSC_OUTPUT_MIN;

	mutex_init(&hsc->lock);
	indio_dev->name = name;
	indio_dev->modes = INDIO_DIRECT_MODE;
	indio_dev->info = &hsc_info;
	indio_dev->channels = hsc->chip->channels;
	indio_dev->num_channels = hsc->chip->num_channels;

	return devm_iio_device_register(dev, indio_dev);
}
EXPORT_SYMBOL_NS(hsc_probe, IIO_HONEYWELL_HSC);

void hsc_remove(struct iio_dev *indio_dev)
{
	iio_device_unregister(indio_dev);
}
EXPORT_SYMBOL_NS(hsc_remove, IIO_HONEYWELL_HSC);

MODULE_AUTHOR("Petre Rodan <2b4eda@subdimension.ro>");
MODULE_DESCRIPTION("Honeywell HSC pressure sensor core driver");
MODULE_LICENSE("GPL");
